name: 'SonarQube Scan'
description: 'Run SonarQube analysis on .NET projects'
author: 'MaestroAI'

inputs:
  sonar_host_url:
    description: 'SonarQube server URL'
    required: true
    default: 'http://localhost:9000'
  sonar_token:
    description: 'SonarQube authentication token'
    required: true
  project_key:
    description: 'SonarQube project key (e.g., maestroai-agents-app)'
    required: true
  project_name:
    description: 'SonarQube project name (e.g., MaestroAI Agents Service)'
    required: true
  solution_path:
    description: 'Path to solution file'
    required: false
    default: 'src'
  dotnet_version:
    description: '.NET version to use'
    required: false
    default: '8.0'
  coverage_exclusions:
    description: 'Coverage exclusions pattern'
    required: false
    default: '**/Migrations/**,**/obj/**,**/bin/**,**/*.Tests/**'
  sources:
    description: 'Source files to analyze'
    required: false
    default: '.'
  github_token:
    description: 'GitHub token for NuGet package authentication'
    required: true

runs:
  using: composite
  steps:
    - name: üì• Setup .NET
      shell: bash
      run: |
        # Install .NET in user directory (no root required)
        if ! command -v dotnet &> /dev/null; then
          echo "Installing .NET SDK ${{ inputs.dotnet_version }} in user directory..."
          mkdir -p $HOME/.dotnet
          curl -fsSL https://dot.net/v1/dotnet-install.sh -o dotnet-install.sh
          chmod +x dotnet-install.sh
          ./dotnet-install.sh --install-dir $HOME/.dotnet --channel ${{ inputs.dotnet_version }}
          echo "$HOME/.dotnet" >> $GITHUB_PATH
          echo "DOTNET_ROOT=$HOME/.dotnet" >> $GITHUB_ENV
        fi
        echo "‚úÖ .NET SDK version: $(dotnet --version)"

    - name: üîß Install SonarScanner for .NET
      shell: bash
      run: |
        dotnet tool install --global dotnet-sonarscanner --version 9.0.0 || dotnet tool update --global dotnet-sonarscanner
        echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

    - name: üîç SonarQube Analysis (Complete)
      shell: bash
      env:
        SONAR_TOKEN: ${{ inputs.sonar_token }}
        NUGET_AUTH_TOKEN: ${{ inputs.github_token }}
        VSS_NUGET_EXTERNAL_FEED_ENDPOINTS: '{"endpointCredentials":[{"endpoint":"https://nuget.pkg.github.com/marcelpiva-org/index.json","username":"marcelpiva-org","password":"${{ inputs.github_token }}"}]}'
      run: |
        # Debug: Verify tokens
        if [ -z "${SONAR_TOKEN}" ]; then
          echo "‚ùå ERROR: SONAR_TOKEN is empty!"
          exit 1
        fi
        if [ -z "${NUGET_AUTH_TOKEN}" ]; then
          echo "‚ùå ERROR: NUGET_AUTH_TOKEN is empty!"
          exit 1
        fi
        echo "‚úÖ SonarQube token received (length: ${#SONAR_TOKEN})"
        echo "‚úÖ NuGet token received (length: ${#NUGET_AUTH_TOKEN})"

        # Configure NuGet with authentication
        dotnet nuget add source https://nuget.pkg.github.com/marcelpiva-org/index.json \
          --name github \
          --username marcelpiva-org \
          --password "${NUGET_AUTH_TOKEN}" \
          --store-password-in-clear-text \
          || echo "‚ö†Ô∏è NuGet source already exists"

        # Begin SonarQube analysis
        echo "üîç Starting SonarQube analysis..."
        dotnet sonarscanner begin \
          /k:"${{ inputs.project_key }}" \
          /n:"${{ inputs.project_name }}" \
          /d:sonar.host.url="${{ inputs.sonar_host_url }}" \
          /d:sonar.token="${SONAR_TOKEN}" \
          /d:sonar.cs.opencover.reportsPaths="**/coverage.opencover.xml" \
          /d:sonar.coverage.exclusions="${{ inputs.coverage_exclusions }}"

        # Restore dependencies with authentication
        echo "üì¶ Restoring dependencies..."
        dotnet restore ${{ inputs.solution_path }}

        # Build solution
        echo "üèóÔ∏è Building solution..."
        dotnet build ${{ inputs.solution_path }} \
          --configuration Release \
          --no-restore

        # Run tests with coverage
        echo "üß™ Running tests with coverage..."
        dotnet test ${{ inputs.solution_path }} \
          --configuration Release \
          --no-build \
          --collect:"XPlat Code Coverage" \
          --results-directory ./coverage \
          -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover \
          || echo "‚ö†Ô∏è Some tests failed, continuing..."

        # End SonarQube analysis
        echo "üîç Completing SonarQube analysis..."
        dotnet sonarscanner end /d:sonar.token="${SONAR_TOKEN}"

    - name: üìä Quality Gate Check
      shell: bash
      env:
        SONAR_TOKEN: ${{ inputs.sonar_token }}
      run: |
        echo "‚è≥ Waiting for Quality Gate result..."
        sleep 10

        TASK_URL=$(curl -s -u "${SONAR_TOKEN}:" \
          "${{ inputs.sonar_host_url }}/api/ce/component?component=${{ inputs.project_key }}" \
          | jq -r '.current.analysisId')

        if [ "$TASK_URL" != "null" ]; then
          QG_STATUS=$(curl -s -u "${SONAR_TOKEN}:" \
            "${{ inputs.sonar_host_url }}/api/qualitygates/project_status?analysisId=${TASK_URL}" \
            | jq -r '.projectStatus.status')

          echo "üìä Quality Gate Status: ${QG_STATUS}"

          if [ "$QG_STATUS" = "ERROR" ]; then
            echo "‚ùå Quality Gate Failed!"
            echo "üîó View details: ${{ inputs.sonar_host_url }}/dashboard?id=${{ inputs.project_key }}"
            exit 1
          else
            echo "‚úÖ Quality Gate Passed!"
            echo "üîó View report: ${{ inputs.sonar_host_url }}/dashboard?id=${{ inputs.project_key }}"
          fi
        else
          echo "‚ö†Ô∏è  Could not retrieve Quality Gate status"
        fi

branding:
  icon: 'check-circle'
  color: 'blue'
