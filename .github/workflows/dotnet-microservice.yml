name: .NET Microservice CI/CD

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Microservice name (e.g., knowledge, chat, agents)'
        required: true
        type: string
      dotnet_version:
        description: '.NET version to use'
        required: false
        type: string
        default: '8.0'
      solution_path:
        description: 'Path to solution file'
        required: false
        type: string
        default: 'src'
      has_tests:
        description: 'Whether the service has tests'
        required: false
        type: boolean
        default: true
      enable_semantic_release:
        description: 'Enable semantic versioning and releases'
        required: false
        type: boolean
        default: true
      update_infrastructure:
        description: 'Update infrastructure repository'
        required: false
        type: boolean
        default: true
      registry:
        description: 'Container registry'
        required: false
        type: string
        default: 'ghcr.io'
      build_amd64:
        description: 'Build AMD64 architecture'
        required: false
        type: boolean
        default: true
      build_arm64:
        description: 'Build ARM64 architecture'
        required: false
        type: boolean
        default: true
      require_manual_approval:
        description: 'Require manual approval before building containers'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ${{ inputs.registry }}
  IMAGE_NAME: marcelpiva-org/maestro-${{ inputs.service_name }}

jobs:
  # Setup Dependencies and Determine Tags
  setup-dependencies:
    name: Setup Dependencies & Tags
    runs-on: [self-hosted, linux, arm64, maestroai]
    outputs:
      cache-hit: ${{ steps.setup.outputs.cache-hit }}
      tags: ${{ steps.tags.outputs.tags }}
      primary_tag: ${{ steps.tags.outputs.primary_tag }}
      version_tag: ${{ steps.tags.outputs.version_tag }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for semantic versioning

    - name: Setup .NET Environment
      id: setup
      uses: marcelpiva-org/maestroai-github-actions/actions/setup-dotnet@main
      with:
        dotnet_version: ${{ inputs.dotnet_version }}
        solution_path: ${{ inputs.solution_path }}
        packages_token: ${{ secrets.PACKAGES_TOKEN }}

    - name: Determine preliminary image tags
      id: tags
      env:
        GITHUB_SHA: ${{ github.sha }}
      run: |
        # Set preliminary tags (will be updated after version-and-release if needed)
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          # Main branch - will be updated after semantic release
          echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
          echo "primary_tag=main-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
          echo "version_tag=main-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          # Develop branch
          echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop-${GITHUB_SHA:0:7},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop-latest" >> $GITHUB_OUTPUT
          echo "primary_tag=develop-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
          echo "version_tag=develop-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
        else
          # Other branches (PRs)
          BRANCH_NAME=$(echo ${{ github.ref }} | sed 's|refs/heads/||' | sed 's|/|-|g')
          echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${BRANCH_NAME}-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
          echo "primary_tag=${BRANCH_NAME}-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
          echo "version_tag=${BRANCH_NAME}-${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
        fi

  # Build Job (Parallel)
  build-solution:
    name: Build Solution
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [setup-dependencies]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET Environment
      uses: marcelpiva-org/maestroai-github-actions/actions/setup-dotnet@main
      with:
        dotnet_version: ${{ inputs.dotnet_version }}
        solution_path: ${{ inputs.solution_path }}
        packages_token: ${{ secrets.PACKAGES_TOKEN }}

    - name: Build Solution
      uses: marcelpiva-org/maestroai-github-actions/actions/build-dotnet@main
      with:
        solution_path: ${{ inputs.solution_path }}

  # Test Job (Parallel)
  run-tests:
    name: Run Tests
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [setup-dependencies]
    if: ${{ inputs.has_tests }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET Environment
      uses: marcelpiva-org/maestroai-github-actions/actions/setup-dotnet@main
      with:
        dotnet_version: ${{ inputs.dotnet_version }}
        solution_path: ${{ inputs.solution_path }}
        packages_token: ${{ secrets.PACKAGES_TOKEN }}

    - name: Run Tests
      uses: marcelpiva-org/maestroai-github-actions/actions/test-dotnet@main
      with:
        solution_path: ${{ inputs.solution_path }}

  # Semantic Version and Release Job
  version-and-release:
    name: Version and Release
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [build-solution, run-tests]
    if: ${{ inputs.enable_semantic_release && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') }}
    outputs:
      version: ${{ steps.semantic.outputs.version }}
      released: ${{ steps.semantic.outputs.released }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Semantic Release
      id: semantic
      uses: marcelpiva-org/maestroai-github-actions/actions/semantic-release@main
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}

  # Update Tags after Version Release
  update-tags:
    name: Update Tags with Version
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [setup-dependencies, version-and-release]
    if: always() && needs.version-and-release.result == 'success' && needs.version-and-release.outputs.released == 'true'
    outputs:
      tags: ${{ steps.final-tags.outputs.tags }}
      primary_tag: ${{ steps.final-tags.outputs.primary_tag }}
      version_tag: ${{ steps.final-tags.outputs.version_tag }}

    steps:
    - name: Update tags with semantic version
      id: final-tags
      run: |
        VERSION="${{ needs.version-and-release.outputs.version }}"
        echo "tags=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT
        echo "primary_tag=${VERSION}" >> $GITHUB_OUTPUT
        echo "version_tag=${VERSION}" >> $GITHUB_OUTPUT

  # Detect which architectures to build automatically
  detect-build-architectures:
    name: Detect Build Architectures
    runs-on: ubuntu-latest
    needs: [setup-dependencies, build-solution, run-tests]
    outputs:
      build_amd64: ${{ steps.detect.outputs.build_amd64 }}
      build_arm64: ${{ steps.detect.outputs.build_arm64 }}
      reason: ${{ steps.detect.outputs.reason }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect architectures to build
      id: detect
      run: |
        BUILD_AMD64="true"
        BUILD_ARM64="true"
        REASON="Default: building all architectures"

        # Get commit message
        COMMIT_MSG="${{ github.event.head_commit.message }}"

        # Check commit message for architecture tags
        if echo "$COMMIT_MSG" | grep -qiE '^\[amd64\]|^amd64:'; then
          BUILD_AMD64="true"
          BUILD_ARM64="false"
          REASON="Commit message contains [amd64] tag - building AMD64 only"
        elif echo "$COMMIT_MSG" | grep -qiE '^\[arm64\]|^arm64:'; then
          BUILD_AMD64="false"
          BUILD_ARM64="true"
          REASON="Commit message contains [arm64] tag - building ARM64 only"
        elif echo "$COMMIT_MSG" | grep -qiE '^\[arch:all\]|^\[all-arch\]'; then
          BUILD_AMD64="true"
          BUILD_ARM64="true"
          REASON="Commit message contains [arch:all] tag - building all architectures"
        fi

        # Check branch patterns
        BRANCH_NAME="${{ github.ref_name }}"
        if [[ "$BRANCH_NAME" =~ ^(hotfix|patch)/ ]]; then
          BUILD_AMD64="true"
          BUILD_ARM64="false"
          REASON="Hotfix/Patch branch detected - building AMD64 only for faster deployment"
        elif [[ "$BRANCH_NAME" =~ ^(release|main|master)$ ]]; then
          BUILD_AMD64="true"
          BUILD_ARM64="true"
          REASON="Production branch detected - building all architectures"
        fi

        # Check for documentation-only changes
        DOC_ONLY=$(git diff --name-only HEAD~1 HEAD | grep -vE '\.(md|txt|rst)$|^docs/|^README' | wc -l)
        if [ "$DOC_ONLY" -eq 0 ]; then
          BUILD_AMD64="false"
          BUILD_ARM64="false"
          REASON="Documentation-only changes - skipping container builds"
        fi

        # Check PR labels (if this is a PR)
        if [ "${{ github.event_name }}" == "pull_request" ]; then
          LABELS="${{ join(github.event.pull_request.labels.*.name, ' ') }}"

          if echo "$LABELS" | grep -q "build-amd64-only"; then
            BUILD_AMD64="true"
            BUILD_ARM64="false"
            REASON="PR label 'build-amd64-only' detected"
          elif echo "$LABELS" | grep -q "build-arm64-only"; then
            BUILD_AMD64="false"
            BUILD_ARM64="true"
            REASON="PR label 'build-arm64-only' detected"
          elif echo "$LABELS" | grep -q "build-all-arch"; then
            BUILD_AMD64="true"
            BUILD_ARM64="true"
            REASON="PR label 'build-all-arch' detected"
          elif echo "$LABELS" | grep -q "skip-build"; then
            BUILD_AMD64="false"
            BUILD_ARM64="false"
            REASON="PR label 'skip-build' detected - skipping container builds"
          fi
        fi

        # Override with workflow_dispatch inputs if provided
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          if [ "${{ inputs.build_amd64 }}" != "" ]; then
            BUILD_AMD64="${{ inputs.build_amd64 }}"
          fi
          if [ "${{ inputs.build_arm64 }}" != "" ]; then
            BUILD_ARM64="${{ inputs.build_arm64 }}"
          fi
          REASON="Manual workflow_dispatch with user-selected architectures"
        fi

        echo "build_amd64=$BUILD_AMD64" >> $GITHUB_OUTPUT
        echo "build_arm64=$BUILD_ARM64" >> $GITHUB_OUTPUT
        echo "reason=$REASON" >> $GITHUB_OUTPUT

        echo "üèóÔ∏è Architecture Detection Result:"
        echo "  AMD64: $BUILD_AMD64"
        echo "  ARM64: $BUILD_ARM64"
        echo "  Reason: $REASON"

    - name: Create detection summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## üèóÔ∏è Build Architecture Detection

        **Decision**:
        - AMD64: ${{ steps.detect.outputs.build_amd64 == 'true' && '‚úÖ Build' || '‚è≠Ô∏è Skip' }}
        - ARM64: ${{ steps.detect.outputs.build_arm64 == 'true' && '‚úÖ Build' || '‚è≠Ô∏è Skip' }}

        **Reason**: ${{ steps.detect.outputs.reason }}

        **Context**:
        - Event: \`${{ github.event_name }}\`
        - Branch: \`${{ github.ref_name }}\`
        - Commit: \`${{ github.sha }}\`
        EOF

  # Manual Approval for Container Builds
  request-build-approval:
    name: Request Build Approval
    runs-on: ubuntu-latest
    needs: [setup-dependencies, build-solution, run-tests]
    if: inputs.require_manual_approval == true
    outputs:
      approved_amd64: ${{ steps.check-approval.outputs.approved_amd64 }}
      approved_arm64: ${{ steps.check-approval.outputs.approved_arm64 }}
      issue_number: ${{ steps.create-issue.outputs.issue_number }}

    steps:
    - name: Create approval issue
      id: create-issue
      uses: actions/github-script@v7
      with:
        script: |
          const issue = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `üöÄ Build Approval Required - ${{ inputs.service_name }} - Run #${context.runNumber}`,
            body: `## Container Build Approval Request

          **Service**: \`${{ inputs.service_name }}\`
          **Workflow Run**: [#${context.runNumber}](${context.payload.repository.html_url}/actions/runs/${context.runId})
          **Branch**: \`${context.ref}\`
          **Commit**: \`${context.sha.substring(0, 7)}\`

          ### ‚úÖ Tests Passed
          - Setup Dependencies & Tags
          - Build Solution
          - Run Tests

          ### üèóÔ∏è Available Architectures
          - AMD64: ${{ inputs.build_amd64 && '‚úÖ Available' || '‚ùå Disabled' }}
          - ARM64: ${{ inputs.build_arm64 && '‚úÖ Available' || '‚ùå Disabled' }}

          ### üìù Approval Commands
          Comment on this issue with one of the following:
          - \`/approve amd64\` - Build AMD64 only
          - \`/approve arm64\` - Build ARM64 only
          - \`/approve all\` - Build both architectures
          - \`/reject\` - Cancel the build

          ‚è±Ô∏è **Timeout**: This workflow will wait for 30 minutes for approval.

          ---
          ü§ñ *This issue was automatically created by the CI/CD pipeline*`
          });

          core.setOutput('issue_number', issue.data.number);
          return issue.data.number;

    - name: Wait for approval
      id: wait-approval
      uses: actions/github-script@v7
      timeout-minutes: 30
      with:
        script: |
          const issueNumber = ${{ steps.create-issue.outputs.issue_number }};
          const maxAttempts = 180; // 30 minutes with 10 second intervals
          let attempts = 0;

          while (attempts < maxAttempts) {
            // Get all comments on the issue
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            // Check for approval commands
            for (const comment of comments.data) {
              const body = comment.body.trim().toLowerCase();

              if (body === '/approve all') {
                core.info('‚úÖ Approved: ALL architectures');
                return { amd64: true, arm64: true, approved: true };
              } else if (body === '/approve amd64') {
                core.info('‚úÖ Approved: AMD64 only');
                return { amd64: true, arm64: false, approved: true };
              } else if (body === '/approve arm64') {
                core.info('‚úÖ Approved: ARM64 only');
                return { amd64: false, arm64: true, approved: true };
              } else if (body === '/reject') {
                core.setFailed('‚ùå Build rejected by user');
                return { amd64: false, arm64: false, approved: false };
              }
            }

            // Wait 10 seconds before checking again
            await new Promise(resolve => setTimeout(resolve, 10000));
            attempts++;
          }

          // Timeout
          core.setFailed('‚è±Ô∏è Approval timeout after 30 minutes');
          return { amd64: false, arm64: false, approved: false };

    - name: Check approval result
      id: check-approval
      run: |
        RESULT='${{ steps.wait-approval.outputs.result }}'
        AMD64=$(echo "$RESULT" | jq -r '.amd64')
        ARM64=$(echo "$RESULT" | jq -r '.arm64')

        echo "approved_amd64=$AMD64" >> $GITHUB_OUTPUT
        echo "approved_arm64=$ARM64" >> $GITHUB_OUTPUT

        echo "‚úÖ Approval result: AMD64=$AMD64, ARM64=$ARM64"

    - name: Close approval issue
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const issueNumber = ${{ steps.create-issue.outputs.issue_number }};

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            body: '‚úÖ Approval processed. Continuing with container builds...'
          });

          await github.rest.issues.update({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            state: 'closed'
          });

  # Build AMD64 Container
  build-amd64:
    name: Build AMD64 Container
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [setup-dependencies, detect-build-architectures, request-build-approval]
    if: |
      always() &&
      (
        (inputs.require_manual_approval == false && needs.detect-build-architectures.outputs.build_amd64 == 'true') ||
        (inputs.require_manual_approval == true && needs.request-build-approval.outputs.approved_amd64 == 'true')
      )

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Build Docker Container
      uses: marcelpiva-org/maestroai-github-actions/actions/docker-build@main
      with:
        registry: ${{ env.REGISTRY }}
        image_name: ${{ env.IMAGE_NAME }}
        tag: ${{ needs.setup-dependencies.outputs.version_tag }}
        architecture: amd64
        github_token: ${{ secrets.GITHUB_TOKEN }}
        packages_token: ${{ secrets.PACKAGES_TOKEN }}

  # Build ARM64 Container
  build-arm64:
    name: Build ARM64 Container
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [setup-dependencies, detect-build-architectures, request-build-approval]
    if: |
      always() &&
      (
        (inputs.require_manual_approval == false && needs.detect-build-architectures.outputs.build_arm64 == 'true') ||
        (inputs.require_manual_approval == true && needs.request-build-approval.outputs.approved_arm64 == 'true')
      )

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Build Docker Container
      uses: marcelpiva-org/maestroai-github-actions/actions/docker-build@main
      with:
        registry: ${{ env.REGISTRY }}
        image_name: ${{ env.IMAGE_NAME }}
        tag: ${{ needs.setup-dependencies.outputs.version_tag }}
        architecture: arm64
        github_token: ${{ secrets.GITHUB_TOKEN }}
        packages_token: ${{ secrets.PACKAGES_TOKEN }}

  # Create Multi-Architecture Manifest
  create-manifest:
    name: Create Multi-Arch Manifest
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [setup-dependencies, build-amd64, build-arm64]
    if: always() && (needs.build-amd64.result == 'success' || needs.build-arm64.result == 'success')

    steps:
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Create and push multi-arch manifest
      run: |
        # Build list of available architecture images
        IMAGES=""
        if [[ "${{ needs.build-amd64.result }}" == "success" ]]; then
          IMAGES="$IMAGES ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup-dependencies.outputs.version_tag }}-amd64"
          echo "‚úÖ AMD64 image available"
        fi
        if [[ "${{ needs.build-arm64.result }}" == "success" ]]; then
          IMAGES="$IMAGES ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup-dependencies.outputs.version_tag }}-arm64"
          echo "‚úÖ ARM64 image available"
        fi

        # Create multi-architecture manifest with available images
        if [[ -n "$IMAGES" ]]; then
          echo "Creating manifest with images:$IMAGES"
          docker buildx imagetools create \
            --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup-dependencies.outputs.version_tag }} \
            $IMAGES

          # Create latest manifest if this is a release
          if [[ "${{ needs.setup-dependencies.outputs.tags }}" == *"latest"* ]]; then
            docker buildx imagetools create \
              --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
              $IMAGES
          fi
        else
          echo "‚ùå No architecture images available to create manifest"
          exit 1
        fi

    - name: Output image info
      run: |
        echo "üê≥ Multi-architecture container images built and pushed:"
        echo "Tags: ${{ needs.setup-dependencies.outputs.tags }}"
        echo "Primary tag: ${{ needs.setup-dependencies.outputs.primary_tag }}"
        echo "AMD64: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup-dependencies.outputs.version_tag }}-amd64"
        echo "ARM64: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup-dependencies.outputs.version_tag }}-arm64"
        echo "Multi-arch: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup-dependencies.outputs.version_tag }}"

  # Update Infrastructure Repository Job
  update-infrastructure:
    name: Update Infrastructure Repository
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [version-and-release, create-manifest]
    if: ${{ inputs.update_infrastructure && needs.create-manifest.result == 'success' }}

    steps:
    - name: Update Infrastructure
      uses: marcelpiva-org/maestroai-github-actions/actions/update-infrastructure@main
      with:
        service_name: ${{ inputs.service_name }}
        version: ${{ needs.version-and-release.outputs.version || 'latest' }}
        packages_token: ${{ secrets.PACKAGES_TOKEN }}

  # Trigger ArgoCD Sync (Optional)
  trigger-argocd-sync:
    name: Trigger ArgoCD Sync
    runs-on: [self-hosted, linux, arm64, maestroai]
    needs: [update-infrastructure]
    if: needs.update-infrastructure.result == 'success'

    steps:
    - name: Trigger ArgoCD Application Sync
      run: |
        echo "üîÑ ArgoCD will automatically detect the changes and sync within 3 minutes"
        echo "Or manually sync via ArgoCD UI: maestroai-${{ inputs.service_name }}-development"
        # Optional: Add ArgoCD CLI commands here if needed
        # argocd app sync maestroai-${{ inputs.service_name }}-development --server argocd-server --auth-token ${{ secrets.ARGOCD_TOKEN }}